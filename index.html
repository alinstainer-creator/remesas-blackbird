<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Blackbird Exchange â€” SR71</title>

  <!-- Libraries (production note in console only) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>
  <script src="https://unpkg.com/papaparse@latest/papaparse.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>

  <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@200;400;600;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"/>

  <style>
    /* --- Estilos generales --- */
    :root {
      --bg: #050606;
      --panel: rgba(6, 10, 10, 0.95);
      --accent: #00caa0;
      --muted: #9aa7a1;
      --glass: rgba(10, 10, 10, 0.6);
    }
    html,body{height:100%;margin:0;font-family:'Exo 2',sans-serif;background:var(--bg);color:#e8f6f2;}
    .app-wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:1rem;}
    .container{
      background: linear-gradient(180deg, rgba(7,10,12,0.95), rgba(6,8,9,0.98));
      border:1px solid rgba(0,200,160,0.08);
      width:96%;
      max-width:880px;
      border-radius:10px;
      padding:1rem;
      box-shadow:0 10px 40px rgba(0,0,0,0.7), inset 0 1px 0 rgba(255,255,255,0.02);
      position:relative;
      overflow:hidden;
    }
    header.app-header{display:flex;align-items:center;gap:12px;margin-bottom:8px}
    .logo{width:56px;height:56px;border-radius:8px;background:linear-gradient(135deg,#002b22,#004d3a);display:flex;align-items:center;justify-content:center;box-shadow:0 4px 18px rgba(0,200,160,0.08);font-weight:800}
    h1.title{font-size:1.05rem;margin:0;color:#dffbf1;text-shadow:0 0 18px rgba(0,200,160,0.06)}
    .subtitle{font-size:0.78rem;color:var(--muted);margin-left:6px}

    /* Controls */
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
    .field{display:flex;flex-direction:column;gap:6px}
    label{font-size:0.7rem;color:var(--muted)}
    select,input{padding:10px;border-radius:8px;border:1px solid rgba(0,200,160,0.08);background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));color:#e6f8f0;font-size:0.95rem}
    .actions{display:flex;gap:8px;align-items:center;margin-top:10px}
    button.btn{padding:10px 14px;border-radius:8px;border:1px solid rgba(0,200,160,0.12);background:transparent;color:#e6f8f0;font-weight:700;cursor:pointer}
    button.btn.primary{background:linear-gradient(90deg,var(--accent),#00f0c0);color:#04211a}
    .info{font-size:0.85rem;color:var(--muted);margin-top:8px}

    /* Result */
    .card{margin-top:10px;padding:12px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02)}
    .card p{margin:0;font-size:0.9rem}
    .card .sub{font-size:0.8rem;color:var(--muted);margin-top:6px}

    /* Background subtle visuals */
    .bg-animated{position:absolute;inset:0;pointer-events:none;mix-blend-mode:screen;opacity:0.08}
    .glow{position:absolute;width:500px;height:500px;border-radius:50%;filter:blur(40px);top:-20%;right:-10%;background:radial-gradient(circle,#00f0c0 0%, transparent 60%);opacity:0.14}
    .glow-2{position:absolute;width:300px;height:300px;border-radius:50%;filter:blur(20px);bottom:-10%;left:-8%;background:radial-gradient(circle,#0099ff 0%, transparent 60%);opacity:0.06}
    .stars-small{position:absolute;inset:0;background-image:radial-gradient(#ffffff 1px, transparent 1px);background-size:20px 20px;opacity:0.02}

    /* small responsive */
    @media (max-width:720px){
      .grid{grid-template-columns:1fr}
      .logo{width:44px;height:44px}
    }

    /* Console-like logs for debugging (hidden by default but useful while debugging) */
    .debug{font-family:monospace;font-size:11px;color:#a3f7df;line-height:1.3;white-space:pre-wrap;max-height:220px;overflow:auto;padding:6px;background:rgba(0,0,0,0.25);border-radius:6px;margin-top:8px;border:1px solid rgba(0,200,160,0.03)}

    /* small helper */
    .muted{color:var(--muted)}
  </style>
</head>
<body>
  <div class="app-wrap">
    <div class="container" id="appContainer">
      <div class="bg-animated" aria-hidden="true">
        <div class="glow"></div>
        <div class="glow-2"></div>
        <div class="stars-small"></div>
      </div>

      <header class="app-header">
        <div class="logo">BB</div>
        <div>
          <h1 class="title">Blackbird Exchange â€” SR71</h1>
          <div class="subtitle">Calculadora de remesas â€” lectura robusta desde Excel/CSV compartido</div>
        </div>
      </header>

      <div id="root"></div>

      <footer style="margin-top:12px;font-size:12px;color:var(--muted)">
        Actualiza el archivo en Google Sheets y se refrescarÃ¡ al recargar la pÃ¡gina. Parser robusto para celdas tipo:
        <span class="muted">"COTIZACION MESA ARG-VEN ðŸ‡¦ðŸ‡·ðŸ‡»ðŸ‡ª" â†’ ARS/VES</span>
      </footer>
    </div>
  </div>

  <!-- App script (Babel in-browser for simplicity) -->
  <script type="text/babel">
    // -------------------------
    // CONFIG
    // -------------------------
    const CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vT9Teo-_5ka3LKx7FXL3x3yV3uf4KhoI61ewnVJyJ90XRnksoObf4CDn-lJvrFKiQ/pub?gid=983978085&single=true&output=csv';

    // Diccionario amplio de equivalencias y sinÃ³nimos a ISO de moneda (expandible)
    const countryToISO = {
      ARG: 'ARS', AR: 'ARS', ARGENTINA: 'ARS',
      VEN: 'VES', VZLA: 'VES', VENEZUELA: 'VES', VE: 'VES',
      CHILE: 'CLP', CL: 'CLP', CHL: 'CLP',
      USA: 'USD', EEUU: 'USD', US: 'USD', UNITEDSTATES: 'USD', UNITED_STATES: 'USD',
      MEX: 'MXN', MEXICO: 'MXN', MX: 'MXN',
      PERU: 'PEN', PER: 'PEN', PE: 'PEN',
      COP: 'COP', CO: 'COP', COLOMBIA: 'COP',
      EUR: 'EUR', EURO: 'EUR',
      BRA: 'BRL', BRASIL: 'BRL', BR: 'BRL',
      UYU: 'UYU', URUGUAY: 'UYU',
      ECU: 'ECU', ECUADOR: 'ECU',
      BRL: 'BRL', ARS: 'ARS', MXN: 'MXN', PEN: 'PEN', USD: 'USD',
      VES: 'VES', CLP: 'CLP'
    };

    // Mapeo para mostrar nombre paÃ­s por cÃ³digo de moneda
    const currencyToCountry = {
      ARS: 'Argentina', VES: 'Venezuela', CLP: 'Chile', USD: 'Estados Unidos',
      MXN: 'MÃ©xico', PEN: 'PerÃº', COP: 'Colombia', EUR: 'Eurozona',
      BRL: 'Brasil', UYU: 'Uruguay', ECU: 'Ecuador'
    };

    // -------------------------
    // UTILITIES
    // -------------------------
    function debugLog(...args) {
      if (window.console && console.log) console.log(...args);
    }

    // Limpia emojis y sÃ­mbolos extraÃ±os
    function stripEmojisAndExtras(text) {
      if (!text) return '';
      // remove emojis (unicode ranges) and weird punctuation
      return text.replace(/[\p{Emoji_Presentation}\p{Extended_Pictographic}]/gu, '')
                 .replace(/[^\p{L}\p{N}\-\/\s]/gu, '') // leave letters, numbers, dash, slash and spaces
                 .replace(/\s{2,}/g, ' ')
                 .trim();
    }

    // Extrae tokens alfanumÃ©ricos (palabras) de una cadena, separando por - / y espacios
    function extractCountryTokens(raw) {
      if (!raw) return [];
      // normalize hyphens and slashes
      const normalized = raw.replace(/â€”/g,'-').replace(/â€“/g,'-').replace(/\u00A0/g,' ').toUpperCase();
      // Remove leading words like COTIZACION, MESA, COTI etc
      const removed = normalized.replace(/\bCOTIZACION\b/gi,'')
                                .replace(/\bCOTI\b/gi,'')
                                .replace(/\bMESA\b/gi,'')
                                .replace(/\bCOTI FINAL\b/gi,'')
                                .replace(/\bCOTI FINAL\b/gi,'')
                                .replace(/\bCOTIZACION MESA\b/gi,'')
                                .replace(/[,()]/g,' ')
                                .trim();
      // If contains slash pair like ARS/VES, return that pair
      const slashMatch = removed.match(/([A-Z]{2,5})\s*\/\s*([A-Z]{2,5})/);
      if (slashMatch) return [slashMatch[1], slashMatch[2]];

      // If contains hyphen like ARG-VEN or ARG - VEN etc.
      const hyphenMatch = removed.match(/([A-Z]{2,6})\s*-\s*([A-Z]{2,6})/);
      if (hyphenMatch) return [hyphenMatch[1], hyphenMatch[2]];

      // Fallback: split by spaces and look for plausible tokens (3-letter or known)
      const parts = removed.split(/\s+/).filter(Boolean);
      // keep tokens that are letters-only
      const candidates = parts.map(p => p.replace(/[^A-Z]/g,'')).filter(Boolean);
      // try to find two consecutive plausible tokens
      for (let i=0;i<candidates.length-1;i++){
        if (candidates[i].length>=2 && candidates[i+1].length>=2) {
          return [candidates[i], candidates[i+1]];
        }
      }
      // last resort: return first two alpha tokens
      return candidates.slice(0,2);
    }

    // Mapea un token a la moneda ISO si existe
    function tokenToISO(token) {
      if (!token) return null;
      const t = token.toUpperCase().replace(/\./g,'').replace(/[^A-Z0-9]/g,'');
      if (countryToISO[t]) return countryToISO[t];
      // certain tokens might be currency code already
      if (['ARS','VES','CLP','USD','MXN','PEN','COP','EUR','BRL','UYU','ECU'].includes(t)) return t;
      return null;
    }

    // Normaliza nÃºmeros con $ . y , (ej: "$1.234,56" -> 1234.56) y porcentajes
    function parseNumberString(s) {
      if (s === undefined || s === null) return NaN;
      let text = String(s).trim();
      // remove surrounding quotes
      text = text.replace(/^"|"$/g,'').trim();
      // ignore cells like "PROVEDOR" or plain text
      // remove currency symbol and percentage signs
      text = text.replace(/[%$]/g,'').trim();
      // sometimes thousands use dot and decimal uses comma -> detect
      // if contains both '.' and ',' and comma to the right of dot, assume dot thousands and comma decimal
      if (/[0-9]+\.[0-9]{3},[0-9]+/.test(text)) {
        text = text.replace(/\./g,'').replace(/,/g,'.');
      } else {
        // if contains dots only and dot appears multiple times and no comma -> remove dots
        if (text.indexOf('.') !== -1 && text.indexOf(',') === -1) {
          // ambiguous: could be "1.234" meaning 1234 or 1.234 -> we'll remove dots if more than one or if rightmost group length is 3
          const parts = text.split('.');
          if (parts.length>1 && parts[parts.length-1].length===3) {
            text = text.replace(/\./g,'');
          } // else keep dot as decimal
        }
        // if comma used as decimal (e.g., 0,156), convert to dot
        if (text.indexOf(',') !== -1 && text.indexOf('.') === -1) {
          text = text.replace(/,/g,'.');
        } else if (text.indexOf(',') !== -1 && text.indexOf('.') !== -1) {
          // if both exist but pattern not matched earlier, assume dots thousands, commas decimals
          text = text.replace(/\./g,'').replace(/,/g,'.');
        }
      }
      // remove any non-number leftover
      text = text.replace(/[^\d\.\-]/g,'');
      const parsed = parseFloat(text);
      return parsed;
    }

    // Busca en una fila (array de celdas) el primer valor no vacÃ­o que parezca ser un par (ej: contiene '-' o '/')
    function findPairCellInRow(row) {
      if (!row || !row.length) return null;
      for (let i=0;i<row.length;i++){
        const cell = (row[i]||'').toString().trim();
        if (!cell) continue;
        const stripped = stripEmojisAndExtras(cell).toUpperCase();
        // heurÃ­stica: si contiene '/' con currency-like tokens o '-' with tokens or contains "COTIZACION"
        if (/[A-Z]{2,6}\s*\/\s*[A-Z]{2,6}/.test(stripped) ||
            /[A-Z]{2,6}\s*-\s*[A-Z]{2,6}/.test(stripped) ||
            /COTIZACION/.test(stripped) || /COTI/.test(stripped)) {
          return { index:i, raw:cell };
        }
      }
      // fallback: return first non-empty
      for (let i=0;i<row.length;i++){
        const cell = (row[i]||'').toString().trim();
        if (cell) return {index:i, raw:cell};
      }
      return null;
    }

    // Busca un nÃºmero en una fila (array de celdas) tomando el primer valor numerico plausible
    function findNumberInRow(row) {
      if (!row || !row.length) return null;
      for (let i=0;i<row.length;i++){
        const c = row[i];
        if (c === undefined || c === null) continue;
        const txt = c.toString().trim();
        if (!txt) continue;
        const parsed = parseNumberString(txt);
        if (!isNaN(parsed)) return { index:i, raw:txt, value: parsed };
      }
      return null;
    }

    // -------------------------
    // CSV LOADER
    // -------------------------
    async function loadCSVText(url) {
      try {
        const resp = await fetch(url, { method:'GET', headers:{'Accept':'text/csv'}});
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const text = await resp.text();
        debugLog('CSV cargado (primeros 200 chars):', text.slice(0,200));
        return text;
      } catch (err) {
        debugLog('Error cargando CSV:', err);
        throw err;
      }
    }

    // -------------------------
    // PARSER PRINCIPAL
    // -------------------------
    /**
     * Estrategia:
     * - Buscar pares en filas que empiezan en 4, 13, 22, ... (es decir fila index 3 + 9*n)
     * - Para cada parRow, tomar rateRow = pairRow + 3 (ej: bcd4 -> fg7)
     * - Para cada pairRow: buscar celda que contenga "COTIZACION" o '-' o '/' o tokens country-like.
     * - Extraer tokens, mapear a ISO. Construir par ISO1/ISO2.
     * - Para rateRow: buscar primera celda numÃ©rica plausible.
     * - Si no se encuentra, aplicar heurÃ­stica alternativa: buscar en filas cercanas +/-2 filas.
     */
    function parseExchangePairsFromPapaResults(results) {
      const data = results.data || [];
      const numRows = data.length;
      const exchange = {}; // map pair -> rate (float)
      const debugEntries = [];

      // We will start scanning from row index 3 (which is "fila 4" human)
      const startIndex = 3;
      const step = 9; // pattern observed: every 9 rows
      for (let r = startIndex; r < numRows; r += step) {
        const pairRowIndex = r; // 0-based
        const rateRowIndex = r + 3; // three rows down

        const pairRow = data[pairRowIndex];
        if (!pairRow) {
          debugEntries.push(`Fila ${pairRowIndex+1} vacÃ­a, se salta.`);
          continue;
        }

        // Buscar la celda con la info del par
        const foundPairCell = findPairCellInRow(pairRow);
        const rawPairText = foundPairCell ? foundPairCell.raw : null;
        debugEntries.push(`Fila ${pairRowIndex+1} (BCD): "${rawPairText ? rawPairText : ''}"`);

        // HeurÃ­stico para extraer tokens
        let tokens = extractCountryTokens(stripEmojisAndExtras(rawPairText || '') || '');
        // If tokens are not good, try alternative: check next row, previous row, or the row that lists explicit pairs like "ARS/USDT,USDT/VES,ARS/VES"
        if (!tokens || tokens.length < 2 || !tokens[0] || !tokens[1]) {
          // look in same row for slash patterns inside any cell (e.g., a CSV cell contains "ARS/USDT,USDT/VES,ARS/VES")
          for (let ci=0; ci < (pairRow||[]).length; ci++) {
            const ctext = (pairRow[ci]||'').toString();
            if (/[A-Z]{2,5}\/[A-Z]{2,5}/i.test(ctext)) {
              const match = ctext.match(/([A-Z]{2,5})\/([A-Z]{2,5})/i);
              if (match) {
                tokens = [match[1].toUpperCase(), match[2].toUpperCase()];
                debugEntries.push(`HeurÃ­stico adicional (slash en fila ${pairRowIndex+1}, col ${ci+1}) -> ${tokens.join('/')}`);
                break;
              }
            }
          }
        }

        // If still not two tokens, try scanning nearby rows for a clearer cell
        if (!tokens || tokens.length < 2 || !tokens[0] || !tokens[1]) {
          for (let offset = -2; offset <= 2; offset++) {
            if (offset === 0) continue;
            const rr = pairRowIndex + offset;
            if (rr < 0 || rr >= numRows) continue;
            const altFound = findPairCellInRow(data[rr]);
            if (altFound) {
              const altTokens = extractCountryTokens(stripEmojisAndExtras(altFound.raw||''));
              if (altTokens && altTokens.length>=2) {
                tokens = altTokens;
                debugEntries.push(`HeurÃ­stico cercano: fila ${rr+1} -> ${tokens.join('/')}`);
                break;
              }
            }
          }
        }

        // Map tokens to ISO
        const isoA = tokenToISO(tokens && tokens[0] ? tokens[0] : null);
        const isoB = tokenToISO(tokens && tokens[1] ? tokens[1] : null);

        if (!isoA || !isoB) {
          debugEntries.push(`Fila ${pairRowIndex+1} no pudo mapear tokens a ISO: tokens=${JSON.stringify(tokens)} -> isoA=${isoA} isoB=${isoB}`);
          // continue scanning (we still attempt to get a rate heuristically if tokens missing)
        } else {
          const pairKey = `${isoA}/${isoB}`;
          // find rate in rateRow
          let rateValue = NaN;
          let rateSourceInfo = null;
          // attempt direct rateRow
          if (rateRowIndex < numRows && rateRowIndex >=0) {
            const rateRow = data[rateRowIndex];
            const foundNumber = findNumberInRow(rateRow);
            if (foundNumber) {
              rateValue = foundNumber.value;
              rateSourceInfo = `fila ${rateRowIndex+1} col ${foundNumber.index+1}`;
              debugEntries.push(`Fila tasa ${rateRowIndex+1}: Asignado ${pairKey} = ${rateValue} (${rateSourceInfo})`);
            } else {
              // maybe the rate is stored in the same row as pairRow but in a column further (some sheets)
              const fallback = findNumberInRow(pairRow);
              if (fallback) {
                rateValue = fallback.value;
                rateSourceInfo = `fila ${pairRowIndex+1} col ${fallback.index+1} (fallback)`;
                debugEntries.push(`Fallback: fila ${pairRowIndex+1} encontrÃ³ nÃºmero ${rateValue} (${rateSourceInfo})`);
              }
            }
          }
          // If not found, search within a small window forward/backwards (up to 5 rows)
          if (isNaN(rateValue)) {
            for (let off= -2; off<=5; off++) {
              const rr = rateRowIndex + off;
              if (rr < 0 || rr >= numRows) continue;
              const candidate = findNumberInRow(data[rr]);
              if (candidate) {
                rateValue = candidate.value;
                rateSourceInfo = `fila ${rr+1} col ${candidate.index+1} (heurÃ­stico off ${off})`;
                debugEntries.push(`HeurÃ­stico tasa: fila ${rr+1} -> ${rateValue}`);
                break;
              }
            }
          }

          // If we found a rate, assign. If rate looks absurd we keep it but log.
          if (!isNaN(rateValue)) {
            exchange[pairKey] = rateValue;
          } else {
            debugEntries.push(`No se encontrÃ³ tasa para ${pairKey} en ventana esperada (fila ${rateRowIndex+1}).`);
          }
        }
      } // end for

      return { exchange, debugEntries };
    }

    // -------------------------
    // REACT COMPONENT
    // -------------------------
    function CurrencyCalculator() {
      const [dataMap, setDataMap] = React.useState(null);
      const [loading, setLoading] = React.useState(true);
      const [error, setError] = React.useState('');
      const [origin, setOrigin] = React.useState('');
      const [dest, setDest] = React.useState('');
      const [amount, setAmount] = React.useState('');
      const [result, setResult] = React.useState(null);
      const [rateView, setRateView] = React.useState(null);
      const [debugText, setDebugText] = React.useState('');
      const containerRef = React.useRef(null);

      // Load and parse CSV once on mount
      React.useEffect(()=> {
        setLoading(true);
        loadCSVText(CSV_URL).then(csvText => {
          Papa.parse(csvText, {
            skipEmptyLines: false, // we need relative row positions
            transform: (v) => (typeof v === 'string') ? v.trim().replace(/^"|"$/g,'') : v,
            complete: (results) => {
              try {
                const parsed = parseExchangePairsFromPapaResults(results);
                setDataMap(parsed.exchange);
                setDebugText(parsed.debugEntries.join('\n'));
                setLoading(false);
                setError('');
                debugLog('Pares de monedas extraÃ­dos:', parsed.exchange);
              } catch (err) {
                setError('Error procesando CSV: ' + err.message);
                setLoading(false);
                debugLog(err);
              }
            },
            error: (err) => {
              setError('Error al parsear CSV: ' + err.message);
              setLoading(false);
              debugLog(err);
            }
          });
        }).catch(err => {
          setError('Error cargando CSV: ' + (err.message||err));
          setLoading(false);
        });
      }, []);

      // small UX helpers
      const playClick = () => {
        try {
          navigator.vibrate && navigator.vibrate(30);
        } catch(e){}
      };

      const formatNumber = (num) => {
        if (num === null || num === undefined || isNaN(num)) return '-';
        try {
          return Number(num).toLocaleString('es-CL', { minimumFractionDigits: 4, maximumFractionDigits: 4 });
        } catch(e) {
          return num;
        }
      };

      function handleCalculate() {
        setError('');
        setResult(null);
        setRateView(null);
        if (!origin || !dest) {
          setError('Selecciona paÃ­s origen y destino.');
          return;
        }
        if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
          setError('Ingresa un monto vÃ¡lido mayor a 0.');
          return;
        }
        playClick();
        const pair = `${origin}/${dest}`;
        if (!dataMap || !dataMap[pair]) {
          setError(`No se encontrÃ³ la tasa de cambio para ${currencyToCountry[origin] || origin} â†’ ${currencyToCountry[dest] || dest}.`);
          return;
        }
        const rate = dataMap[pair];
        const converted = parseFloat(amount) * rate;
        setResult({
          fromIso: origin, toIso: dest, rate, amount: parseFloat(amount), converted
        });
      }

      function handleViewRate() {
        setError('');
        setResult(null);
        if (!origin || !dest) {
          setError('Selecciona paÃ­s origen y destino.');
          return;
        }
        playClick();
        const pair = `${origin}/${dest}`;
        if (!dataMap || !dataMap[pair]) {
          setError(`No se encontrÃ³ la tasa de cambio para ${currencyToCountry[origin] || origin} â†’ ${currencyToCountry[dest] || dest}.`);
          return;
        }
        const rate = dataMap[pair];
        setRateView({ from: origin, to: dest, rate });
      }

      // Countries dropdown from currencyToCountry mapping
      const countries = Object.keys(currencyToCountry).sort();

      if (loading) {
        return (
          <div style={{padding:'20px'}} className="muted">Cargando tasas de cambio... (parser robusto)</div>
        );
      }

      return (
        <div>
          {error && <div className="card" style={{borderColor:'rgba(255,0,0,0.06)',background:'rgba(255,0,0,0.02)'}}>{error}</div>}
          <div className="grid">
            <div className="field">
              <label>PaÃ­s / Moneda Origen</label>
              <select value={origin} onChange={(e)=>setOrigin(e.target.value)}>
                <option value="">Selecciona paÃ­s origen</option>
                {countries.map(c => <option key={c} value={c}>{currencyToCountry[c]}</option>)}
              </select>
            </div>
            <div className="field">
              <label>PaÃ­s / Moneda Destino</label>
              <select value={dest} onChange={(e)=>setDest(e.target.value)}>
                <option value="">Selecciona paÃ­s destino</option>
                {countries.map(c => <option key={c} value={c}>{currencyToCountry[c]}</option>)}
              </select>
            </div>
            <div className="field">
              <label>Monto</label>
              <input type="number" inputMode="numeric" step="0.0001" min="0" value={amount} onChange={(e)=>setAmount(e.target.value)} placeholder="Ingresa monto"/>
            </div>
            <div className="field">
              <label>Acciones</label>
              <div style={{display:'flex',gap:8}}>
                <button className="btn" onClick={()=>{ setAmount(''); setOrigin(''); setDest(''); setResult(null); setRateView(null); setError(''); }}>Limpiar</button>
                <button className="btn primary" onClick={handleCalculate}>Calcular</button>
                <button className="btn" onClick={handleViewRate}>Ver Tasa</button>
              </div>
            </div>
          </div>

          <div className="info">Fuente: CSV compartido. Parser preparado para leer pares en filas tipo BCD4, BCD13, BCD22 ... (y buscar la tasa en FG3 filas mÃ¡s abajo)</div>

          {/* Rate display */}
          {rateView && (
            <div className="card">
              <p><strong>Tasa de Cambio</strong></p>
              <div className="sub">1 {rateView.from} ({currencyToCountry[rateView.from] || rateView.from}) = {formatNumber(rateView.rate)} {rateView.to} ({currencyToCountry[rateView.to] || rateView.to})</div>
            </div>
          )}

          {/* Result */}
          {result && (
            <div className="card" style={{marginTop:12}}>
              <p><strong>Resultado de la ConversiÃ³n</strong></p>
              <div className="sub">{formatNumber(result.amount)} {currencyToCountry[result.fromIso] || result.fromIso} = <strong>{formatNumber(result.converted)}</strong> {currencyToCountry[result.toIso] || result.toIso}</div>
              <div className="sub" style={{marginTop:6}}>Tasa utilizada: 1 {result.fromIso} = {formatNumber(result.rate)} {result.toIso}</div>
            </div>
          )}

          {/* Debug area (collapsible style) */}
          <div style={{marginTop:10}}>
            <details>
              <summary style={{cursor:'pointer', color:'var(--muted)'}}>Mostrar debug del parser</summary>
              <pre className="debug">{debugText || 'Sin debug'}</pre>
            </details>
          </div>

        </div>
      );
    }

    // Render
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<CurrencyCalculator />);

    // -------------------------
    // Nota: Si quieres mÃ¡s animaciÃ³n/immersiÃ³n:
    // - puedo aÃ±adir mÃ¡s partÃ­culas y movimiento del fondo.
    // - por ahora he dejado efectos suaves (glow + stars) para no romper la UI.
    // -------------------------
  </script>
</body>
</html>

